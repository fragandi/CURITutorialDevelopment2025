<?xml version='1.0' encoding='utf-8'?>
<chapter xml:id="ch-invarianttheory">
    <title>Invariant Theory</title>
    <introduction>
        <p>
This chapter is co-authored by Francesca Gandini, Sumner Strom, Al Ashir Intisar. 
In this chapter we will present an overview of the theory behind the algorithms implemented in the <url href="https://www.macaulay2.com/doc/Macaulay2/share/doc/Macaulay2/InvariantRing/html/index.html">InvariantRing</url> software package 
in the open-source Computer Algebra System <url href="http://www2.macaulay2.com">Macaulay2 (M2)</url>.
        </p>

        <p>
          You can access an online version of this chapter with live code cell at <url href="https://fragandi.github.io/CURITutorialDevelopment2025/"></url>.
          There you can also learn how to set up a virtual machine on Github with Codespaces so that you write and run M2 code from anywhere.
          A turn-key repository for creating a Codespace
           <!-- (<xref ref="sec-codespaces"/>)  -->
           for Macaulay2 is available at
        <url href="https://github.com/fragandi/M2-codespace">fragandi/M2-codespace</url>. 
        </p>
        <p>
          We also include some background on orbit sums necessary to implement an algorithm to compute invariants for permutations actions. 
          We have worked with a group of collaborators on the first version of the code for this algorithm at the Macaulay2 Workshop at Tulane University in April 2025
          and plan to further test it and release it with Macaulay2 in Fall 2025.
        </p>
        <p>
          We finish the chapter with a selection of examples that illustrate the current capabilities of the InvariantRing package.
          You can run the provided code in your local installation of M2 or go to the online version and execute the code cells on your browser.
          Works well even on mobile devices!
        </p>
    </introduction>

<section xml:id="sec-invariantrings">
       <title>A concrete introduction to invariant rings</title>
       <!-- <subsection xml:id="subsec-introduction">
        <title>Introduction to invariant theory</title>
                <p>
                    With our research we also had  a large focus on making the theory behind invariant rings accessible 
                  and digestible for undergraduate students. This included making a chapter covering some computational tools 
                  within invariant theory briefly. We used this to work on a packet, Orbit Sums, in Macaulay2 for efficient computing of permutation groups 
                  within invariant rings.

                </p>
    </subsection> -->
       <subsection xml:id="subsec-finite-matrix-groups">
        <title>Finite Matrix Groups</title>
        <p>
          We can think of a (linear) action of a group on a vector space
          concretely by interpreting each group element as a matrix and describing the action as matrix multiplication on vectors.
          We can then evaluate any polynomial on a vector and its image after the action.
        </p>
<example>
   <p>
        Consider <me>M =  \begin{pmatrix}
1 \amp 0 \\
0 \amp -1 \\
\end{pmatrix} </me> and the vector <m>\bar x = \begin{pmatrix} x\\ y\\ \end{pmatrix}</m>
This gives <m>M \bar x = \begin{pmatrix}
x \\
-y  \\
\end{pmatrix}</m>. Thus for the polynomial <me> f(\bar x) = f(\begin{pmatrix}
x \\
y  \\
\end{pmatrix}) = x+y</me> and we have, <me>f(M\bar x) = f(\begin{pmatrix}
x \\
-y  \\
\end{pmatrix})= x-y</me>.

    </p>
</example>
<p>
  More formally, for <m> G </m> a finite group we will consider a linear representation of <m> G </m>  
        via its action on a finite dimensional vector space <m>V </m> over a field <m>K </m> of characteristics zero. 
        In general, most of the results in this chapter hold in the non-modular case 
        i.e., when the characteristics of the field does not divide the order of the group. 
        However finite fields are not fully supported by the current version of the InvariantRing package 
        and the development of such functionalities is an active area of development.  
</p>
      
<p>
  If <m> V </m> is faithful representation of <m> G </m> of dimension <m> m</m>, the image of the representation is isomorphic to <m> G </m> 
  and so we consider <m> G </m> as a finite <term>matrix group</term>.
</p>
   
        <definition><p> Suppose <m>|G| &lt; \infty</m> and <m>G \leq GL_m(\mathbb{K})</m>,  then <m>G</m> is a finite matrix group.
        
        </p></definition>
  <example>
     <p>
        Let us consider a two-dimesional representation of <m>C_2</m>, the cyclic group of order 2. <me>\left\langle \begin{pmatrix}
1 \amp 0 \\
0 \amp -1 \\
\end{pmatrix} \right\rangle = \left\{ \begin{pmatrix}
1 \amp 0 \\
0 \amp -1 \\
\end{pmatrix},\begin{pmatrix}
1 \amp 0 \\
0 \amp 1 \\
\end{pmatrix} \right \} \cong C_2</me>
    </p>
  </example>
    </subsection>


    <subsection xml:id="subsec-invariant-rings">
        <title>Invariant Rings</title>
        <p> We will work with a polynomial ring in <m>n</m> variables over the field <m>\mathbb{K}</m>.  
          We use the 
            notation <m>\bar x = (x_1, x_2,..., x_n)</m> and abuse it by saying <m>\mathbb{K}[x_1,x_2,...,x_n]=\mathbb{K}[\bar x]</m> and 
            <m>f(x_1,x_2,...,x_n)=f(\bar x)</m> for <m>f \in R = \mathbb{K}[\bar x]</m>. 

            <definition> <p> Let <m>G</m> be a finite matrix group within <m>GL_n(\mathbb{K})</m>. We say that
<m>f\in \mathbb{K}[\bar x]</m> is invariant under the action of <m>G</m> if and only if
<me>
  f(A\bar x) = f(\bar x),
</me>
for all <m>A \in G</m>.
 </p></definition>
</p><p>
Ex. <m>f(\bar x)=x</m> and <m>f(\bar x) = x +y^2</m> in <m>\mathbb{K}[x_1,x_2,...,x_n]</m> is invariant under <me>C_2 = \left\langle\begin{bmatrix}
1 \amp 0 \\
0 \amp -1 \\
\end{bmatrix} \right\rangle</me>
However <m>f(\bar x)=x+y</m> is not.
        </p>
        <p>
            <definition><p> <m>R^G : =  \{f \in R \, | f(A\bar x) = f(\bar x), \forall A \in G\} \subseteq R</m>
            is the invariant ring for the action of <m>G</m>
            </p></definition>
        </p>
    </subsection>
    <subsection xml:id="subsec-reynolds-operator">
        <title>Reynolds Operator</title>
        <p>
            Idea: "Averaging" over the action of <m>G</m> we get an invariant
        </p>
        <p>
            <definition> <p> <m>R_G: R \xrightarrow{} R^G</m> <me>R_G(f) = \frac{1}{|G|} \sum_{A\in G} f(A \bar x) </me>
        </p></definition>
        </p>
        <p>Example for the Group action <m>C_2 = \left\langle\begin{bmatrix}
            1 \amp 0 \\
            0 \amp -1 \\
            \end{bmatrix}\right\rangle</m>: <me>R_G(x+y) = \frac{1}{2} ((x+y) + (x-y)) = x\in R^G</me>

        </p>
    </subsection>
</section>

    <section xml:id="sec-degree-bounds-algorithms">
     <title>Degree bounds and algorithms</title>
    <subsection xml:id="subsec-noether-degree-bound">
        <title>Nöether Degree Bound(NDB)</title>
        <p>
            <theorem><p> (Noether): <me>R^G = \mathbb{K} [ R_G(\bar x^{\bar \beta}) | \; |\bar \beta| \leq |G|]</me>
            <m>\implies</m> NDB : The ring of invariants is generated in degrees <m>\leq |G|</m>
            </p></theorem>
        </p>
        <p>
            Note: This is a computational tool! We can apply <m>R_G</m> to all the finitely many monomials in degrees <m>\leq |G|</m> to get generators for <m>R^G</m>.
        </p>
    </subsection>
    <subsection xml:id="subsec-hilbert-ideal">
        <title>Hilbert Ideal</title>
        <p>
            Note: In general for <m>\{ f_1,..., f_s\} \subseteq \R</m>, <m>\{f_1,...f_s\}</m> and <m>\R</m> can be quite different objects
        </p>
        <p>
            <theorem><p> Let <m>J_G = R(R^G)_t</m>, ideal generated by all positive degree invariants.
            If <m>J_G = (f_1,...,f_s)</m> and <m>f_i\in R^G, \,\, \forall i</m>
             (apply <m>R^G</m> if it is not), then <m>R^G = \mathbb{K}[f_1,...f_s]</m>
            </p></theorem>
        </p>
    </subsection>
    <subsection xml:id="subsec-presentations">
        <title>Presentations</title>
            <p>
                <definition><p>Definition: Let <m>S = \mathbb{K}[f_1,...f_s] \subset R</m>.
                A presentation of <m>S</m> is a map, <me>T=: \mathbb{K}[u_1,...u_s] \xrightarrow{\phi}S</me>
                such that <m>\frac{T}{\text{ker}(\phi)} \cong S</m> With the syzygies of <m>f_i</m>'s
                giving the presentation ideal.
                </p></definition>
            </p>
            <p>
                <proposition><p>(Elimination Theory): In <m>S \bigotimes \mathbb{K}[u_1,...,u_s] = \mathbb{K}[x_1,...,x_n,u_1,...u_s]</m> consider the ideal,
                <me>I = (u_i - f_x(\bar x) | \, \left\langle f_i\right\rangle = S</me>
                Then,
                <me>\text{ker} (\phi)= I \cap \mathbb{K}[u_1,...,u_s]</me>
                </p></proposition>
            </p>
            <p>
                <algorithm><p> Compute a Groebner Basis <m>G</m> for <m>I</m> with elimination order for the <m>x</m>'s.
                Then, <m>G \cap \mathbb{K}[y_1,...y_s]</m>  is the Groebner Basis for <m>ker \phi</m>
                </p></algorithm>
            </p>
    </subsection>
    <subsection xml:id="subsec-graph-of-linear-actions">
        <title>Graph of Linear Actions</title>
        <p>
            <definition> <p>Let <m>G \leq GL_n(\mathbb{K}), \,\, G\curvearrowright \mathbb{K}^n =:V, \,\, |G|\infty</m>.
            For <m>A\in G</m> consider,
            <me>V_A = \{(\bar v, A\bar v)|\,\,v\in V\} \subseteq V\bigotimes V</me>
            Then <m>A_G = \cup_{A\in G}V_A</m> is the subspace arrangement associated to the action of G.
            </p></definition>
        </p>
        <p>
            Note: <m>V_A</m> is a linear subspace, <m>\mathbb{I}(V_A):=</m> set of polynomials vanishing on <m>\mathbb{V}_A</m> is a linear ideal.
            Example: <me>V_{\begin{bmatrix}
            1 \amp 0 \\
            0 \amp -1 \\
            \end{bmatrix}} = \{(x_1,x_2,x_1,-x_2)\} = V(y_1,-x_1, y_2+x_2)</me>
        </p>
    </subsection>
    <subsection xml:id="subsec-subspace-arrangement-approach">
        <title>Subspace Arrangement Approach</title>
        <p>
            <theorem><p>
                (Dekseu): Let <m>I_G = \mathbb{I}(A_G) = \cap_{A\in G}\mathbb{I}(V_A) \subseteq \mathbb{K}[x_1,...x_n,y_1,...y_n].</m>
            Then <me>(I_G +(y_1,...,y_n)) \cap \R = J_G</me> This uses elimination theory and the Hilbert ideal.
            </p> </theorem>
        </p>
        <p>
            Note: The same approach works in the exterior algebra!
        </p>
        <p>
            <theorem><p>Let <m>I_G^{'} = \cap_{A\in G} \mathbb{I}(V_A) \subseteq \Lambda(\bar x, \bar y)</m>.
            Then <me>(I_G^{'} +(y_1,...y_n)) \cap \Lambda(x_1,...,x_n) = J_G^{'} : = \Lambda(\bar x)(\Lambda(\bar x)^G)_+</me>
            </p></theorem>
        </p>
        <p>
            Note: This approach is slow for polynomials, but might be fast for skew polynomials.
        </p>
    </subsection>
    <subsection xml:id="subsec-AGWM">
        <title>Abelian GPS and Weight Matrices</title>
        <p>
            Let <m>G \cong \mathbb{Z}_d, \bigoplus....\bigoplus \mathbb{Z}_{dr}, \,\,\,\,\, d_i|d_{i+1}</m> for <m>1 \leq i \leq r-1</m>
            <me>\left\langle g_1\right\rangle \bigoplus...\bigoplus\left\langle g_r \right\rangle, \,\,\,\,\, |g_i| =d_i</me>
            A diagonal action of <m>G</m> on <m>R</m> is given by
            <me>g_i \cdot x_j = \mu_i^{\omega ij}x_j</me>
            for <m> \mu_i : d_i^{th}</m> primitive root of unity and <m>i \in [x]</m>,<m>j \in [n]</m>.
             And encoded in the weight matrix <m>W = (\omega_{ij})_{ij} =  
            \begin{bmatrix}
                x_1 \amp \cdots     \amp   x_n   \\
                \vdots \amp \ddots \amp      \\
                x_n \amp      \amp
            \end{bmatrix}
</m>
        </p>
        <p>
            <theorem><p> <m>\bar x^{\bar \beta} \in R^G \iff W_{\bar \beta}\cong (0,...,0)</m> for
            zeros being the weight of <m>g_1</m> acting on <m>\bar x^{\bar \beta}</m> and being modulo <m>d_i</m>.
            </p></theorem>
        </p>
        <p>
            Note: We can examine all monomials <m>|\bar \beta| \leq |G|</m> and sort them by their weight <m>W\bar \beta</m>.
            The ones with weight <m>\bar 0</m> will be invariant!
        </p>

    </subsection>
    <subsection xml:id="subsec-orbitsums">
        <title>Orbit Sums</title>

                <p>
                    Say the symmetric group <m>\Sigma_n </m> acts on <m>\{1, ... , n\}</m> by permuting its elements. 
                    Then the representation of <m>\Sigma_n </m> is <m>V = \mathbb{F}^n</m> with a set of basis vectors <m>\{e_1, ... , e_n\}</m>.
                    This means that <m>\Sigma_n </m> acts on <m>V</m> by permuting its basis vectors, <m>\{\sigma(e_1),...,\sigma(e_n)\}</m> we have a permutation representation.

                </p>

<p>
    Example of left acting matrix on the basis:
<me> (1 \,2\,3\,4) =  \begin{bmatrix}
0 \amp 1 \amp 0 \amp 0 \\
0 \amp 0 \amp 1 \amp 0 \\
0 \amp 0 \amp 0 \amp 1 \\
1 \amp 0 \amp 0 \amp 0 
\end{bmatrix}   
</me>
and then we have it acting,
<me> \begin{bmatrix}
0 \amp 1 \amp 0 \amp 0 \\
0 \amp 0 \amp 1 \amp 0 \\
0 \amp 0 \amp 0 \amp 1 \\
1 \amp 0 \amp 0 \amp 0 
\end{bmatrix} \begin{bmatrix}
v_1 \\
v_2 \\
v_3\\
v_4
\end{bmatrix}   =    \begin{bmatrix}
v_4 \\
v_1 \\
v_2\\
v_3
\end{bmatrix}
</me>
</p>
<p>These are useful tools for calculating invariants because we simplify to Linear Algebra! 
An example of invariants are symmetric polynomials which we can use permutation 
representations on.
</p>
<definition xml:id="def-symmetricpolynomial">
  <statement>
    <p>
      Symmetric Polynomial: For <m>f \in R[x_1,x_2,...,x_n]</m> a polynomial is a Symmetric Polynomial if 
      <m>f(x_1,x_2,...,x_n) = f(x_{\sigma(1)},x_{\sigma(2)},...,x_{\sigma(n)})</m> 
      for all permutations of <m>\sigma \in S_n</m>
    </p>
  </statement>
</definition>
<definition xml:id="def-elemsymm">
  <statement>
    <p>
      Elementary Symmetric Polynomials: <m>e_0,e_1,...,e_n</m> in <m>R[x_1,...,x_n]</m> 
      are defined by <me>e_{m}=\sum x_{j_1}x_{j_2}...x_{j_m} </me>

    </p>
  </statement>
</definition>
<p>
  We now introduce some tools for calculating properties of these permutation groups. Such as Orbit sums and Special Monomials.
</p>
<definition xml:id="def-orbitsum">
  <statement>
    <p>
      Orbit Sums are the sum of all orbit elements. An orbit is A <m>G-orbit</m> 
      for the left acting group on an element <m>x_0</m> is <me>G-orbit = \{gx_0 | g \in G\}</me>
    </p>
  </statement>
</definition>
<proposition xml:id="prop-orbitsumsformvectorspace">
  <statement>
    <p>
      The orbit sums of any given degree <m>d</m> form a basis for the vector space <m>\mathbb{F}(V)^G</m>
    </p>
  </statement>
</proposition>
<definition xml:id="def-specialmonomials">
  <statement>
    <p>
      A monomial is special within <m>\mathbb{F}[x_1, ... , x_n]</m> if the partitions satisfy <m>x_1^n x_2^{n-1}....x_n^0</m>.
    </p>
  </statement>
</definition>
<p>Statement: <m>x_1^n x_2^{n-1}....x_n^0</m> would not be special within <m>\mathbb{F}[x_1, ... , x_{n-1}]</m>.</p>
<p>
  Algorithmically, we can reduce any monomial to special by reducing the upper degrees repeatedly until the 
  monomial is special.
  Example: within <m>\mathbb{F}[x_1,x_2,x_3]</m>
  <me>
    x_1^4x_2^2x_3 \mapsto x_1^2 x_2
  </me>
  
</p>
<p>
  This all leads to a theorem.
</p>
<theorem xml:id="thm-gobel">
  <statement>
    <p>
      (Göbel): Let <m>\phi:G \mapsto GL(n,\mathbb{F})</m> be a permutation 
      representation of a finite group for <m>\mathbb{F} = \mathbb{F}[x_1,...,x_n]</m>. Then the ring of invariants <m>\mathbb{F}[V]^G</m>
      is generated as an algebra by the top elementary symmetric function <m>s_n = x_1...x_n</m> and the orbit sum of monomials.
    </p>
  </statement>
</theorem>
<p>
  This theorem is a possibly important tool for reducing computational need to generate these algebra. 
</p>


    </subsection>
  </section>


   <section xml:id="sec-invariantrings-packages">
        <title>InvariantRings package </title>
<p>
  
We conclude with references to the algorithms implemented in the InvariantRing package and examples of its implementation. 
Version 2.0 of this package was accepted for publication in volume 14 of Journal of Software for Algebra and Geometry on 2023-09-14, in the article The InvariantRing package for Macaulay2 
(DOI: 10.2140/jsag.2024.14.5). That version can be obtained from the journal or from the Macaulay2 source code repository.
</p>


<subsection xml:id="subsec-references">
        <title>References for the implemented algorithms</title>
  
<ul>
  <li>
    <p> An elimination theory algorithm that computes the Hilbert ideal for any linearly reductive group: Derksen, H. and Kemper, G. (2015). Computational Invariant Theory. Heidelberg: Springer. Algorithm 4.1.9, pp 159-164
  </p>
    </li>
  <li>
    <p>A simple and efficient algorithm for invariants of tori based on: Derksen, H. and Kemper, G. (2015). Computational Invariant Theory. Heidelberg: Springer. Algorithm 4.3.1 pp 174-177
    </p>  
    </li>   
      <li>
          <p>An adaptation of the tori algorithm for invariants of finite abelian groups based on: Gandini, F. Ideals of Subspace Arrangements. Thesis (Ph.D.)-University of Michigan. 2019. ISBN: 978-1392-76291-2. pp 29-34.
        </p>
         </li>
          <li>
            <p>King's algorithm and the linear algebra method for invariants of finite groups: Derksen, H. and Kemper, G. (2015). Computational Invariant Theory. Heidelberg: Springer. Algorithm 3.8.2, pp 107-109; pp 72-74
        </p>
         </li>
        <li>
          <p>The algorithms for primary and secondary invariants, and Molien series of finite groups implemented in version 1.1.0 of this package by: Hawes, T. Computing the invariant ring of a finite group. JSAG, Vol. 5 (2013). pp 15-19. DOI: 10.2140/jsag.2013.5.15
        </p>
  </li>
  <li>
    <p>
      The orbit sum approach is under development following  Mara D. Neusel, Texas Tech University, Lubbock, TX. Publication: The Student Mathematical Library. Publication Year 2007: Volume 36, 
      DOI: <url href="http://dx.doi.org/10.1090/stml/036"/>
    </p>
  </li>
</ul>
      
    </subsection>

        <subsection xml:id="sec-invariantring-demos">
          <title>InvariantRing Library Demos</title>
        
          <p>
            The <code>InvariantRing</code> package in Macaulay2 provides tools to study and compute invariant rings of group actions.
            To get started, install the package.
          </p>
        
          <sage language="macaulay2">
            <input>
              installPackage "InvariantRing"
            </input>
          </sage>
        
          <subsubsection>
            <title>SL₂ Actions on C² and Variants</title>
        
            <p>
              A classical example: the standard action of SL₂ on ℂ². The ring <code>R</code> carries a linearly reductive action from SL₂ defined via the matrix <code>SL2std</code>. The invariants and Hilbert ideal are then computed:
            </p>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                B = QQ[a,b,c,d]
                A = ideal(a*d - b*c - 1)
                SL2std = matrix{{a,b},{c,d}}
                R = QQ[x_1..x_2]
                V = linearlyReductiveAction(A,SL2std,R) 
                invariants V
                elapsedTime hilbertIdeal V
              </input>
            </sage>
          </subsubsection>
        
          <subsubsection>
            <title>Diagonal Actions of Abelian Groups</title>
        
            <p>
              This example demonstrates a diagonal action of the abelian group ℂ₃ × ℂ₃ on a polynomial ring. After defining the diagonal weights, we compute the invariant ring and its Hilbert series:
            </p>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                R = QQ[x_1..x_3]
                W = matrix{{1,0,1},{0,1,1}}
                L = {3,3}
                T = diagonalAction(W,L,R)
                S = R^T
                invariantRing T
                I = definingIdeal S
                Q = ring I
                F = res I
                hilbertSeries S
                equivariantHilbertSeries T
              </input>
            </sage>
          </subsubsection>
        
          <subsubsection>
            <title>Linearly Reductive Actions: Permutations and Binary Forms</title>
        
            <p>
              Here's how the symmetric group S₂ acts via a matrix of projection operators. We identify which polynomials are invariant under the group action:
            </p>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                S = QQ[z]
                A = ideal(z^2 - 1)
                M = matrix{{(1+z)/2, (1-z)/2},{(1-z)/2,(1+z)/2}}
                R = QQ[a,b]
                X = linearlyReductiveAction(A,M,R)
                isInvariant(a,X)
                invariants X
              </input>
            </sage>
        
            <p>
              Now we compute the invariants of binary quadratics and quartics using SL₂ actions. These involve basis substitutions in a ring of forms and are more computationally demanding:
            </p>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                S = QQ[a,b,c,d]
                I = ideal(a*d - b*c - 1)
                A = S[u,v]
                M = transpose (map(S,A)) last coefficients sub(basis(2,A),{u=>a*u+b*v,v=>c*u+d*v})
                R = QQ[x_1..x_3]
                L = linearlyReductiveAction(I,M,R)
                hilbertIdeal L
                invariants L
                invariants(L,4)
                invariants(L,5)
              </input>
            </sage>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                S = QQ[a,b,c,d]
                I = ideal(a*d - b*c - 1)
                A = S[u,v]
                M4 = transpose (map(S,A)) last coefficients sub(basis(4,A),{u=>a*u+b*v,v=>c*u+d*v})
                R4 = QQ[x_1..x_5]
                L4 = linearlyReductiveAction(I,M4,R4)
                elapsedTime hilbertIdeal L4
                elapsedTime X = invariants L4
                g2 = X_0/12
                g3 = -X_1/216
                256*(g2^3 - 27*g3^2)
                1728*(g2^3)/(g2^3 - 27*g3^2)
              </input>
            </sage>
          </subsubsection>
        
          <subsubsection>
            <title>Matrix Invariants and Conjugation Actions</title>
        
            <p>
              We define SL₂ actions on 2×2 and 3×3 matrices of binary or ternary forms. The conjugation action creates sophisticated invariants under change of basis:
            </p>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                S = QQ[g_(1,1)..g_(2,2),t]
                I = ideal((det genericMatrix(S,2,2))*t-1)
                Q = S/I
                A = Q[y_(1,1)..y_(2,2)]
                Y = transpose genericMatrix(A,2,2)
                g = promote(genericMatrix(S,2,2),A)
                G = reshape(A^1,A^4,g*Y*inverse(g)) // (vars A)
                G = lift(map(A^4,A^4,G),S)
                R = QQ[x_(1,1)..x_(2,2)]
                L = linearlyReductiveAction(I,G,R)
                elapsedTime H=hilbertIdeal(L)
                elapsedTime invariants L
              </input>
            </sage>
        
            <p>
              The same process is repeated for 3×3 matrices. This involves 9-dimensional vector spaces and is more computationally demanding:
            </p>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                S = QQ[g_(1,1)..g_(3,3),t]
                I = ideal((det genericMatrix(S,3,3))*t-1)
                Q = S/I
                A = Q[y_(1,1)..y_(3,3)]
                Y = transpose genericMatrix(A,3,3)
                g = promote(genericMatrix(S,3,3),A)
                G = reshape(A^1,A^9,g*Y*inverse(g)) // (vars A)
                G = lift(map(A^9,A^9,G),S)
                R = QQ[x_(1,1)..x_(3,3)]
                L = linearlyReductiveAction(I,G,R)
                elapsedTime H=hilbertIdeal(L)
                elapsedTime invariants(L,1)
                elapsedTime invariants(L,2)
                elapsedTime invariants(L,3)
              </input>
            </sage>
          </subsubsection>
        
          <subsubsection>
            <title>Finite Group Actions: S₄ Example</title>
        
            <p>
              Finally, we examine the symmetric group S₄ acting on 4 variables. We use both King’s algorithm and a slower linear algebra method to compute primary and secondary invariants:
            </p>
        
            <sage language="macaulay2">
              <input>
                restart
                needsPackage "InvariantRing"
                R = QQ[x_1..x_4]
                L = apply({[2,1,3,4],[2,3,4,1]},permutationMatrix);
                S4 = finiteAction(L,R)
                elapsedTime invariants S4
                elapsedTime invariants(S4,Strategy=>"LinearAlgebra")
                elapsedTime p=primaryInvariants S4
                elapsedTime secondaryInvariants(p,S4)
                elapsedTime hironakaDecomposition(S4)
              </input>
            </sage>
          </subsubsection>
          </subsection>
   </section>

</chapter>
